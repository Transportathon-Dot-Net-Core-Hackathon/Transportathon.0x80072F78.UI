//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class Services {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AddressCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Address/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AddressUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Address/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Address/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Address/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAddress(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Address/GetAddress/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAddress(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginDTO | undefined): Observable<TokenDTOCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Auth/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOCustomResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<TokenDTOCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTokenByClient(body: ClientLoginDTO | undefined): Observable<ClientTokenDTOCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Auth/CreateTokenByClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTokenByClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTokenByClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientTokenDTOCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientTokenDTOCustomResponse>;
        }));
    }

    protected processCreateTokenByClient(response: HttpResponseBase): Observable<ClientTokenDTOCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientTokenDTOCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTokenByRefreshToken(body: RefreshTokenDTO | undefined): Observable<TokenDTOCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Auth/CreateTokenByRefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTokenByRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTokenByRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOCustomResponse>;
        }));
    }

    protected processCreateTokenByRefreshToken(response: HttpResponseBase): Observable<TokenDTOCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    revokeRefreshToken(body: RefreshTokenDTO | undefined): Observable<TokenDTOCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Auth/RevokeRefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOCustomResponse>;
        }));
    }

    protected processRevokeRefreshToken(response: HttpResponseBase): Observable<TokenDTOCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create2(body: CommentCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Comment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate2(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update2(body: CommentUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Comment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete2(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Comment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete2(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll2(): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Comment/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll2(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getComment(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Comment/GetComment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetComment(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create3(body: CompanyCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Company/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate3(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update3(body: CompanyUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Company/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate3(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete3(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Company/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete3(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll3(): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Company/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll3(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCompany(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Company/GetCompany/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetCompany(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create4(body: DriverCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Driver/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate4(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update4(body: DriverUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Driver/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate4(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete4(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Driver/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete4(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll4(): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Driver/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll4(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDriver(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Driver/GetDriver/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetDriver(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create5(body: OfferCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Offer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate5(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update5(body: OfferUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Offer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate5(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete5(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Offer/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete5(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param relational (optional) 
     * @return Success
     */
    getAll5(relational: boolean | undefined): Observable<OfferDTOListCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Offer/GetAll?";
        if (relational === null)
            throw new Error("The parameter 'relational' cannot be null.");
        else if (relational !== undefined)
            url_ += "relational=" + encodeURIComponent("" + relational) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferDTOListCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferDTOListCustomResponse>;
        }));
    }

    protected processGetAll5(response: HttpResponseBase): Observable<OfferDTOListCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferDTOListCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getOffer(id: string): Observable<OfferDTOCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Offer/GetOffer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOffer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOffer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferDTOCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferDTOCustomResponse>;
        }));
    }

    protected processGetOffer(response: HttpResponseBase): Observable<OfferDTOCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferDTOCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    myOffers(): Observable<OfferDTOListCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Offer/MyOffers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyOffers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyOffers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OfferDTOListCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OfferDTOListCustomResponse>;
        }));
    }

    protected processMyOffers(response: HttpResponseBase): Observable<OfferDTOListCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferDTOListCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create6(body: TeamCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Team/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate6(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update6(body: TeamUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Team/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate6(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete6(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Team/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete6(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll6(): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Team/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll6(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTeam(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Team/GetTeam/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetTeam(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create7(body: TeamWorkerCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TeamWorker/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate7(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update7(body: TeamWorkerUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TeamWorker/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate7(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete7(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TeamWorker/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete7(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll7(): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TeamWorker/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll7(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTeamWorker(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TeamWorker/GetTeamWorker/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamWorker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamWorker(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetTeamWorker(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create8(body: TransportationRequestCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TransportationRequest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate8(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update8(body: TransportationRequestUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TransportationRequest/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate8(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete8(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TransportationRequest/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete8(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param relational (optional) 
     * @return Success
     */
    getAll8(relational: boolean | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TransportationRequest/GetAll?";
        if (relational === null)
            throw new Error("The parameter 'relational' cannot be null.");
        else if (relational !== undefined)
            url_ += "relational=" + encodeURIComponent("" + relational) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll8(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTransportationRequest(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/TransportationRequest/GetTransportationRequest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportationRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportationRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetTransportationRequest(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getUser(): Observable<UserDTOCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/User/GetUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTOCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTOCustomResponse>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserDTOCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTOCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUser(body: CreateUserDTO | undefined): Observable<IdentityResultCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/User/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResultCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResultCustomResponse>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<IdentityResultCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResultCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create9(body: VehicleCreateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Vehicle/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processCreate9(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update9(body: VehicleUpdateDTO | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Vehicle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processUpdate9(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete9(id: string | undefined): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Vehicle/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processDelete9(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll9(): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Vehicle/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetAll9(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getVehicle(id: string): Observable<NoContentCustomResponse> {
        let url_ = this.baseUrl + "/api/Transportathon/Vehicle/GetVehicle/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoContentCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoContentCustomResponse>;
        }));
    }

    protected processGetVehicle(response: HttpResponseBase): Observable<NoContentCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContentCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Address implements IAddress {
    id?: string;
    addressType?: number;
    addressName?: string | undefined;
    city?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressType = _data["addressType"];
            this.addressName = _data["addressName"];
            this.city = _data["city"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.alley = _data["alley"];
            this.buildingNumber = _data["buildingNumber"];
            this.apartmentNumber = _data["apartmentNumber"];
            this.postCode = _data["postCode"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressType"] = this.addressType;
        data["addressName"] = this.addressName;
        data["city"] = this.city;
        data["district"] = this.district;
        data["street"] = this.street;
        data["alley"] = this.alley;
        data["buildingNumber"] = this.buildingNumber;
        data["apartmentNumber"] = this.apartmentNumber;
        data["postCode"] = this.postCode;
        return data;
    }
}

export interface IAddress {
    id?: string;
    addressType?: number;
    addressName?: string | undefined;
    city?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
}

export class AddressCreateDTO implements IAddressCreateDTO {
    addressType?: number;
    addressName?: string | undefined;
    city?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;

    constructor(data?: IAddressCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.addressName = _data["addressName"];
            this.city = _data["city"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.alley = _data["alley"];
            this.buildingNumber = _data["buildingNumber"];
            this.apartmentNumber = _data["apartmentNumber"];
            this.postCode = _data["postCode"];
        }
    }

    static fromJS(data: any): AddressCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddressCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["addressName"] = this.addressName;
        data["city"] = this.city;
        data["district"] = this.district;
        data["street"] = this.street;
        data["alley"] = this.alley;
        data["buildingNumber"] = this.buildingNumber;
        data["apartmentNumber"] = this.apartmentNumber;
        data["postCode"] = this.postCode;
        return data;
    }
}

export interface IAddressCreateDTO {
    addressType?: number;
    addressName?: string | undefined;
    city?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
}

export class AddressUpdateDTO implements IAddressUpdateDTO {
    id?: string;
    addressType?: number;
    addressName?: string | undefined;
    city?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;

    constructor(data?: IAddressUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressType = _data["addressType"];
            this.addressName = _data["addressName"];
            this.city = _data["city"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.alley = _data["alley"];
            this.buildingNumber = _data["buildingNumber"];
            this.apartmentNumber = _data["apartmentNumber"];
            this.postCode = _data["postCode"];
        }
    }

    static fromJS(data: any): AddressUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddressUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressType"] = this.addressType;
        data["addressName"] = this.addressName;
        data["city"] = this.city;
        data["district"] = this.district;
        data["street"] = this.street;
        data["alley"] = this.alley;
        data["buildingNumber"] = this.buildingNumber;
        data["apartmentNumber"] = this.apartmentNumber;
        data["postCode"] = this.postCode;
        return data;
    }
}

export interface IAddressUpdateDTO {
    id?: string;
    addressType?: number;
    addressName?: string | undefined;
    city?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
}

export class AspNetUser implements IAspNetUser {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    firstName?: string | undefined;
    familyName?: string | undefined;
    userImage?: string | undefined;

    constructor(data?: IAspNetUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.firstName = _data["firstName"];
            this.familyName = _data["familyName"];
            this.userImage = _data["userImage"];
        }
    }

    static fromJS(data: any): AspNetUser {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        data["firstName"] = this.firstName;
        data["familyName"] = this.familyName;
        data["userImage"] = this.userImage;
        return data;
    }
}

export interface IAspNetUser {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    firstName?: string | undefined;
    familyName?: string | undefined;
    userImage?: string | undefined;
}

export class ClientLoginDTO implements IClientLoginDTO {
    clientId?: string | undefined;
    clientSecret?: string | undefined;

    constructor(data?: IClientLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): ClientLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

export interface IClientLoginDTO {
    clientId?: string | undefined;
    clientSecret?: string | undefined;
}

export class ClientTokenDTO implements IClientTokenDTO {
    accessToken?: string | undefined;
    accessTokenExpiration?: Date;

    constructor(data?: IClientTokenDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenExpiration = _data["accessTokenExpiration"] ? new Date(_data["accessTokenExpiration"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientTokenDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientTokenDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenExpiration"] = this.accessTokenExpiration ? this.accessTokenExpiration.toISOString() : <any>undefined;
        return data;
    }
}

export interface IClientTokenDTO {
    accessToken?: string | undefined;
    accessTokenExpiration?: Date;
}

export class ClientTokenDTOCustomResponse implements IClientTokenDTOCustomResponse {
    data?: ClientTokenDTO;
    error?: ErrorDTO;

    constructor(data?: IClientTokenDTOCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ClientTokenDTO.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDTO.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientTokenDTOCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientTokenDTOCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientTokenDTOCustomResponse {
    data?: ClientTokenDTO;
    error?: ErrorDTO;
}

export class CommentCreateDTO implements ICommentCreateDTO {
    score?: number;
    date?: Date;
    text?: string | undefined;

    constructor(data?: ICommentCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data["score"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): CommentCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CommentCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["text"] = this.text;
        return data;
    }
}

export interface ICommentCreateDTO {
    score?: number;
    date?: Date;
    text?: string | undefined;
}

export class CommentUpdateDTO implements ICommentUpdateDTO {
    id?: string;
    score?: number;
    date?: Date;
    text?: string | undefined;

    constructor(data?: ICommentUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.score = _data["score"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): CommentUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CommentUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["score"] = this.score;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["text"] = this.text;
        return data;
    }
}

export interface ICommentUpdateDTO {
    id?: string;
    score?: number;
    date?: Date;
    text?: string | undefined;
}

export class Company implements ICompany {
    id?: string;
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;
    companyUsers?: AspNetUser;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.title = _data["title"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.street = _data["street"];
            this.alley = _data["alley"];
            this.district = _data["district"];
            this.buildingNumber = _data["buildingNumber"];
            this.apartmentNumber = _data["apartmentNumber"];
            this.postCode = _data["postCode"];
            this.vkn = _data["vkn"];
            this.companyUsersId = _data["companyUsersId"];
            this.companyUsers = _data["companyUsers"] ? AspNetUser.fromJS(_data["companyUsers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["title"] = this.title;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["street"] = this.street;
        data["alley"] = this.alley;
        data["district"] = this.district;
        data["buildingNumber"] = this.buildingNumber;
        data["apartmentNumber"] = this.apartmentNumber;
        data["postCode"] = this.postCode;
        data["vkn"] = this.vkn;
        data["companyUsersId"] = this.companyUsersId;
        data["companyUsers"] = this.companyUsers ? this.companyUsers.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompany {
    id?: string;
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;
    companyUsers?: AspNetUser;
}

export class CompanyCreateDTO implements ICompanyCreateDTO {
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;

    constructor(data?: ICompanyCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.title = _data["title"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.street = _data["street"];
            this.alley = _data["alley"];
            this.district = _data["district"];
            this.buildingNumber = _data["buildingNumber"];
            this.apartmentNumber = _data["apartmentNumber"];
            this.postCode = _data["postCode"];
            this.vkn = _data["vkn"];
            this.companyUsersId = _data["companyUsersId"];
        }
    }

    static fromJS(data: any): CompanyCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["title"] = this.title;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["street"] = this.street;
        data["alley"] = this.alley;
        data["district"] = this.district;
        data["buildingNumber"] = this.buildingNumber;
        data["apartmentNumber"] = this.apartmentNumber;
        data["postCode"] = this.postCode;
        data["vkn"] = this.vkn;
        data["companyUsersId"] = this.companyUsersId;
        return data;
    }
}

export interface ICompanyCreateDTO {
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;
}

export class CompanyDTO implements ICompanyDTO {
    id?: string;
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;
    companyUsers?: AspNetUser;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.title = _data["title"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.street = _data["street"];
            this.alley = _data["alley"];
            this.district = _data["district"];
            this.buildingNumber = _data["buildingNumber"];
            this.apartmentNumber = _data["apartmentNumber"];
            this.postCode = _data["postCode"];
            this.vkn = _data["vkn"];
            this.companyUsersId = _data["companyUsersId"];
            this.companyUsers = _data["companyUsers"] ? AspNetUser.fromJS(_data["companyUsers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["title"] = this.title;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["street"] = this.street;
        data["alley"] = this.alley;
        data["district"] = this.district;
        data["buildingNumber"] = this.buildingNumber;
        data["apartmentNumber"] = this.apartmentNumber;
        data["postCode"] = this.postCode;
        data["vkn"] = this.vkn;
        data["companyUsersId"] = this.companyUsersId;
        data["companyUsers"] = this.companyUsers ? this.companyUsers.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyDTO {
    id?: string;
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;
    companyUsers?: AspNetUser;
}

export class CompanyUpdateDTO implements ICompanyUpdateDTO {
    id?: string;
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;

    constructor(data?: ICompanyUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.title = _data["title"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.street = _data["street"];
            this.alley = _data["alley"];
            this.district = _data["district"];
            this.buildingNumber = _data["buildingNumber"];
            this.apartmentNumber = _data["apartmentNumber"];
            this.postCode = _data["postCode"];
            this.vkn = _data["vkn"];
            this.companyUsersId = _data["companyUsersId"];
        }
    }

    static fromJS(data: any): CompanyUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["title"] = this.title;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["street"] = this.street;
        data["alley"] = this.alley;
        data["district"] = this.district;
        data["buildingNumber"] = this.buildingNumber;
        data["apartmentNumber"] = this.apartmentNumber;
        data["postCode"] = this.postCode;
        data["vkn"] = this.vkn;
        data["companyUsersId"] = this.companyUsersId;
        return data;
    }
}

export interface ICompanyUpdateDTO {
    id?: string;
    companyName?: string | undefined;
    title?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    street?: string | undefined;
    alley?: string | undefined;
    district?: string | undefined;
    buildingNumber?: string | undefined;
    apartmentNumber?: string | undefined;
    postCode?: string | undefined;
    vkn?: string | undefined;
    companyUsersId?: string;
}

export class CreateUserDTO implements ICreateUserDTO {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    familyName?: string | undefined;

    constructor(data?: ICreateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.familyName = _data["familyName"];
        }
    }

    static fromJS(data: any): CreateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["familyName"] = this.familyName;
        return data;
    }
}

export interface ICreateUserDTO {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    familyName?: string | undefined;
}

export enum DocumentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class DriverCreateDTO implements IDriverCreateDTO {
    name?: string | undefined;
    surname?: string | undefined;
    experience?: string | undefined;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    age?: number;
    drivingLicenceTypes?: number[] | undefined;

    constructor(data?: IDriverCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.experience = _data["experience"];
            this.phoneNumber = _data["phoneNumber"];
            this.eMail = _data["eMail"];
            this.age = _data["age"];
            if (Array.isArray(_data["drivingLicenceTypes"])) {
                this.drivingLicenceTypes = [] as any;
                for (let item of _data["drivingLicenceTypes"])
                    this.drivingLicenceTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): DriverCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DriverCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["experience"] = this.experience;
        data["phoneNumber"] = this.phoneNumber;
        data["eMail"] = this.eMail;
        data["age"] = this.age;
        if (Array.isArray(this.drivingLicenceTypes)) {
            data["drivingLicenceTypes"] = [];
            for (let item of this.drivingLicenceTypes)
                data["drivingLicenceTypes"].push(item);
        }
        return data;
    }
}

export interface IDriverCreateDTO {
    name?: string | undefined;
    surname?: string | undefined;
    experience?: string | undefined;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    age?: number;
    drivingLicenceTypes?: number[] | undefined;
}

export class DriverDTO implements IDriverDTO {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    experience?: string | undefined;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    age?: number;
    drivingLicenceTypes?: number[] | undefined;

    constructor(data?: IDriverDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.experience = _data["experience"];
            this.phoneNumber = _data["phoneNumber"];
            this.eMail = _data["eMail"];
            this.age = _data["age"];
            if (Array.isArray(_data["drivingLicenceTypes"])) {
                this.drivingLicenceTypes = [] as any;
                for (let item of _data["drivingLicenceTypes"])
                    this.drivingLicenceTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): DriverDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DriverDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["experience"] = this.experience;
        data["phoneNumber"] = this.phoneNumber;
        data["eMail"] = this.eMail;
        data["age"] = this.age;
        if (Array.isArray(this.drivingLicenceTypes)) {
            data["drivingLicenceTypes"] = [];
            for (let item of this.drivingLicenceTypes)
                data["drivingLicenceTypes"].push(item);
        }
        return data;
    }
}

export interface IDriverDTO {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    experience?: string | undefined;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    age?: number;
    drivingLicenceTypes?: number[] | undefined;
}

export class DriverUpdateDTO implements IDriverUpdateDTO {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    experience?: string | undefined;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    age?: number;
    drivingLicenceTypes?: number[] | undefined;

    constructor(data?: IDriverUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.experience = _data["experience"];
            this.phoneNumber = _data["phoneNumber"];
            this.eMail = _data["eMail"];
            this.age = _data["age"];
            if (Array.isArray(_data["drivingLicenceTypes"])) {
                this.drivingLicenceTypes = [] as any;
                for (let item of _data["drivingLicenceTypes"])
                    this.drivingLicenceTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): DriverUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DriverUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["experience"] = this.experience;
        data["phoneNumber"] = this.phoneNumber;
        data["eMail"] = this.eMail;
        data["age"] = this.age;
        if (Array.isArray(this.drivingLicenceTypes)) {
            data["drivingLicenceTypes"] = [];
            for (let item of this.drivingLicenceTypes)
                data["drivingLicenceTypes"].push(item);
        }
        return data;
    }
}

export interface IDriverUpdateDTO {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    experience?: string | undefined;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    age?: number;
    drivingLicenceTypes?: number[] | undefined;
}

export class ErrorDTO implements IErrorDTO {
    errorcode?: number;
    title?: string | undefined;
    details?: string[] | undefined;
    stacktrace?: string | undefined;

    constructor(data?: IErrorDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorcode = _data["errorcode"];
            this.title = _data["title"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(item);
            }
            this.stacktrace = _data["stacktrace"];
        }
    }

    static fromJS(data: any): ErrorDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorcode"] = this.errorcode;
        data["title"] = this.title;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        data["stacktrace"] = this.stacktrace;
        return data;
    }
}

export interface IErrorDTO {
    errorcode?: number;
    title?: string | undefined;
    details?: string[] | undefined;
    stacktrace?: string | undefined;
}

export class IdentityError implements IIdentityError {
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IIdentityError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IdentityError {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface IIdentityError {
    code?: string | undefined;
    description?: string | undefined;
}

export class IdentityResult implements IIdentityResult {
    readonly succeeded?: boolean;
    readonly errors?: IdentityError[] | undefined;

    constructor(data?: IIdentityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(IdentityError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityResult {
    succeeded?: boolean;
    errors?: IdentityError[] | undefined;
}

export class IdentityResultCustomResponse implements IIdentityResultCustomResponse {
    data?: IdentityResult;
    error?: ErrorDTO;

    constructor(data?: IIdentityResultCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? IdentityResult.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDTO.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IdentityResultCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResultCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIdentityResultCustomResponse {
    data?: IdentityResult;
    error?: ErrorDTO;
}

export class LoginDTO implements ILoginDTO {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDTO {
    userName?: string | undefined;
    password?: string | undefined;
}

export class NoContent implements INoContent {

    constructor(data?: INoContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): NoContent {
        data = typeof data === 'object' ? data : {};
        let result = new NoContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface INoContent {
}

export class NoContentCustomResponse implements INoContentCustomResponse {
    data?: NoContent;
    error?: ErrorDTO;

    constructor(data?: INoContentCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? NoContent.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDTO.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NoContentCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NoContentCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface INoContentCustomResponse {
    data?: NoContent;
    error?: ErrorDTO;
}

export class OfferCreateDTO implements IOfferCreateDTO {
    transportationRequestId?: string;
    companyId?: string;
    userId?: string;
    teamId?: string;
    driverId?: string;
    offerTime?: Date;
    price?: number;
    note?: string | undefined;
    status?: DocumentStatus;

    constructor(data?: IOfferCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transportationRequestId = _data["transportationRequestId"];
            this.companyId = _data["companyId"];
            this.userId = _data["userId"];
            this.teamId = _data["teamId"];
            this.driverId = _data["driverId"];
            this.offerTime = _data["offerTime"] ? new Date(_data["offerTime"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.note = _data["note"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): OfferCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OfferCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transportationRequestId"] = this.transportationRequestId;
        data["companyId"] = this.companyId;
        data["userId"] = this.userId;
        data["teamId"] = this.teamId;
        data["driverId"] = this.driverId;
        data["offerTime"] = this.offerTime ? this.offerTime.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["note"] = this.note;
        data["status"] = this.status;
        return data;
    }
}

export interface IOfferCreateDTO {
    transportationRequestId?: string;
    companyId?: string;
    userId?: string;
    teamId?: string;
    driverId?: string;
    offerTime?: Date;
    price?: number;
    note?: string | undefined;
    status?: DocumentStatus;
}

export class OfferDTO implements IOfferDTO {
    transportationRequestId?: string;
    transportationRequest?: TransportationRequestDTO;
    companyId?: string;
    company?: CompanyDTO;
    userId?: string;
    user?: UserDTO;
    teamId?: string;
    team?: TeamDTO;
    driverId?: string;
    driver?: DriverDTO;
    offerTime?: Date;
    price?: number;
    note?: string | undefined;
    status?: number;

    constructor(data?: IOfferDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transportationRequestId = _data["transportationRequestId"];
            this.transportationRequest = _data["transportationRequest"] ? TransportationRequestDTO.fromJS(_data["transportationRequest"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? CompanyDTO.fromJS(_data["company"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDTO.fromJS(_data["user"]) : <any>undefined;
            this.teamId = _data["teamId"];
            this.team = _data["team"] ? TeamDTO.fromJS(_data["team"]) : <any>undefined;
            this.driverId = _data["driverId"];
            this.driver = _data["driver"] ? DriverDTO.fromJS(_data["driver"]) : <any>undefined;
            this.offerTime = _data["offerTime"] ? new Date(_data["offerTime"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.note = _data["note"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): OfferDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transportationRequestId"] = this.transportationRequestId;
        data["transportationRequest"] = this.transportationRequest ? this.transportationRequest.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["teamId"] = this.teamId;
        data["team"] = this.team ? this.team.toJSON() : <any>undefined;
        data["driverId"] = this.driverId;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>undefined;
        data["offerTime"] = this.offerTime ? this.offerTime.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["note"] = this.note;
        data["status"] = this.status;
        return data;
    }
}

export interface IOfferDTO {
    transportationRequestId?: string;
    transportationRequest?: TransportationRequestDTO;
    companyId?: string;
    company?: CompanyDTO;
    userId?: string;
    user?: UserDTO;
    teamId?: string;
    team?: TeamDTO;
    driverId?: string;
    driver?: DriverDTO;
    offerTime?: Date;
    price?: number;
    note?: string | undefined;
    status?: number;
}

export class OfferDTOCustomResponse implements IOfferDTOCustomResponse {
    data?: OfferDTO;
    error?: ErrorDTO;

    constructor(data?: IOfferDTOCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? OfferDTO.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDTO.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OfferDTOCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDTOCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOfferDTOCustomResponse {
    data?: OfferDTO;
    error?: ErrorDTO;
}

export class OfferDTOListCustomResponse implements IOfferDTOListCustomResponse {
    data?: OfferDTO[] | undefined;
    error?: ErrorDTO;

    constructor(data?: IOfferDTOListCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OfferDTO.fromJS(item));
            }
            this.error = _data["error"] ? ErrorDTO.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OfferDTOListCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDTOListCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOfferDTOListCustomResponse {
    data?: OfferDTO[] | undefined;
    error?: ErrorDTO;
}

export class OfferUpdateDTO implements IOfferUpdateDTO {
    id?: string;
    transportationRequestId?: string;
    companyId?: string;
    userId?: string;
    teamId?: string;
    driverId?: string;
    offerTime?: Date;
    price?: number;
    note?: string | undefined;
    status?: DocumentStatus;

    constructor(data?: IOfferUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transportationRequestId = _data["transportationRequestId"];
            this.companyId = _data["companyId"];
            this.userId = _data["userId"];
            this.teamId = _data["teamId"];
            this.driverId = _data["driverId"];
            this.offerTime = _data["offerTime"] ? new Date(_data["offerTime"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.note = _data["note"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): OfferUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OfferUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transportationRequestId"] = this.transportationRequestId;
        data["companyId"] = this.companyId;
        data["userId"] = this.userId;
        data["teamId"] = this.teamId;
        data["driverId"] = this.driverId;
        data["offerTime"] = this.offerTime ? this.offerTime.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["note"] = this.note;
        data["status"] = this.status;
        return data;
    }
}

export interface IOfferUpdateDTO {
    id?: string;
    transportationRequestId?: string;
    companyId?: string;
    userId?: string;
    teamId?: string;
    driverId?: string;
    offerTime?: Date;
    price?: number;
    note?: string | undefined;
    status?: DocumentStatus;
}

export class RefreshTokenDTO implements IRefreshTokenDTO {
    token?: string | undefined;

    constructor(data?: IRefreshTokenDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): RefreshTokenDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IRefreshTokenDTO {
    token?: string | undefined;
}

export class TeamCreateDTO implements ITeamCreateDTO {
    companyId?: string;
    teamWorkerId?: string[] | undefined;

    constructor(data?: ITeamCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["teamWorkerId"])) {
                this.teamWorkerId = [] as any;
                for (let item of _data["teamWorkerId"])
                    this.teamWorkerId!.push(item);
            }
        }
    }

    static fromJS(data: any): TeamCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeamCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        if (Array.isArray(this.teamWorkerId)) {
            data["teamWorkerId"] = [];
            for (let item of this.teamWorkerId)
                data["teamWorkerId"].push(item);
        }
        return data;
    }
}

export interface ITeamCreateDTO {
    companyId?: string;
    teamWorkerId?: string[] | undefined;
}

export class TeamDTO implements ITeamDTO {
    id?: string;
    companyId?: string;
    company?: Company;
    teamWorkerId?: string[] | undefined;
    teamWorkers?: TeamWorker[] | undefined;

    constructor(data?: ITeamDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            if (Array.isArray(_data["teamWorkerId"])) {
                this.teamWorkerId = [] as any;
                for (let item of _data["teamWorkerId"])
                    this.teamWorkerId!.push(item);
            }
            if (Array.isArray(_data["teamWorkers"])) {
                this.teamWorkers = [] as any;
                for (let item of _data["teamWorkers"])
                    this.teamWorkers!.push(TeamWorker.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.teamWorkerId)) {
            data["teamWorkerId"] = [];
            for (let item of this.teamWorkerId)
                data["teamWorkerId"].push(item);
        }
        if (Array.isArray(this.teamWorkers)) {
            data["teamWorkers"] = [];
            for (let item of this.teamWorkers)
                data["teamWorkers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITeamDTO {
    id?: string;
    companyId?: string;
    company?: Company;
    teamWorkerId?: string[] | undefined;
    teamWorkers?: TeamWorker[] | undefined;
}

export class TeamUpdateDTO implements ITeamUpdateDTO {
    id?: string;
    companyId?: string;
    teamWorkerId?: string[] | undefined;

    constructor(data?: ITeamUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["teamWorkerId"])) {
                this.teamWorkerId = [] as any;
                for (let item of _data["teamWorkerId"])
                    this.teamWorkerId!.push(item);
            }
        }
    }

    static fromJS(data: any): TeamUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.teamWorkerId)) {
            data["teamWorkerId"] = [];
            for (let item of this.teamWorkerId)
                data["teamWorkerId"].push(item);
        }
        return data;
    }
}

export interface ITeamUpdateDTO {
    id?: string;
    companyId?: string;
    teamWorkerId?: string[] | undefined;
}

export class TeamWorker implements ITeamWorker {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    experience?: string | undefined;

    constructor(data?: ITeamWorker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.age = _data["age"];
            this.phoneNumber = _data["phoneNumber"];
            this.eMail = _data["eMail"];
            this.experience = _data["experience"];
        }
    }

    static fromJS(data: any): TeamWorker {
        data = typeof data === 'object' ? data : {};
        let result = new TeamWorker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["age"] = this.age;
        data["phoneNumber"] = this.phoneNumber;
        data["eMail"] = this.eMail;
        data["experience"] = this.experience;
        return data;
    }
}

export interface ITeamWorker {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    experience?: string | undefined;
}

export class TeamWorkerCreateDTO implements ITeamWorkerCreateDTO {
    name?: string | undefined;
    surname?: string | undefined;
    age?: number;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    experience?: string | undefined;

    constructor(data?: ITeamWorkerCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.age = _data["age"];
            this.phoneNumber = _data["phoneNumber"];
            this.eMail = _data["eMail"];
            this.experience = _data["experience"];
        }
    }

    static fromJS(data: any): TeamWorkerCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeamWorkerCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["age"] = this.age;
        data["phoneNumber"] = this.phoneNumber;
        data["eMail"] = this.eMail;
        data["experience"] = this.experience;
        return data;
    }
}

export interface ITeamWorkerCreateDTO {
    name?: string | undefined;
    surname?: string | undefined;
    age?: number;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    experience?: string | undefined;
}

export class TeamWorkerUpdateDTO implements ITeamWorkerUpdateDTO {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    experience?: string | undefined;

    constructor(data?: ITeamWorkerUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.age = _data["age"];
            this.phoneNumber = _data["phoneNumber"];
            this.eMail = _data["eMail"];
            this.experience = _data["experience"];
        }
    }

    static fromJS(data: any): TeamWorkerUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeamWorkerUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["age"] = this.age;
        data["phoneNumber"] = this.phoneNumber;
        data["eMail"] = this.eMail;
        data["experience"] = this.experience;
        return data;
    }
}

export interface ITeamWorkerUpdateDTO {
    id?: string;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number;
    phoneNumber?: string | undefined;
    eMail?: string | undefined;
    experience?: string | undefined;
}

export class TokenDTO implements ITokenDTO {
    token?: string | undefined;
    refreshToken?: string | undefined;
    refreshTokenExpiration?: Date;

    constructor(data?: ITokenDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"] ? new Date(_data["refreshTokenExpiration"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration ? this.refreshTokenExpiration.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITokenDTO {
    token?: string | undefined;
    refreshToken?: string | undefined;
    refreshTokenExpiration?: Date;
}

export class TokenDTOCustomResponse implements ITokenDTOCustomResponse {
    data?: TokenDTO;
    error?: ErrorDTO;

    constructor(data?: ITokenDTOCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TokenDTO.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDTO.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenDTOCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDTOCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITokenDTOCustomResponse {
    data?: TokenDTO;
    error?: ErrorDTO;
}

export class TransportationRequestCreateDTO implements ITransportationRequestCreateDTO {
    requestType?: number;
    outputAddressId?: string;
    destinationAddressId?: string;
    userId?: string;
    weight?: number;
    volume?: number;
    note?: string | undefined;
    createdDate?: Date;
    documentStatus?: number;

    constructor(data?: ITransportationRequestCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestType = _data["requestType"];
            this.outputAddressId = _data["outputAddressId"];
            this.destinationAddressId = _data["destinationAddressId"];
            this.userId = _data["userId"];
            this.weight = _data["weight"];
            this.volume = _data["volume"];
            this.note = _data["note"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.documentStatus = _data["documentStatus"];
        }
    }

    static fromJS(data: any): TransportationRequestCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransportationRequestCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestType"] = this.requestType;
        data["outputAddressId"] = this.outputAddressId;
        data["destinationAddressId"] = this.destinationAddressId;
        data["userId"] = this.userId;
        data["weight"] = this.weight;
        data["volume"] = this.volume;
        data["note"] = this.note;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["documentStatus"] = this.documentStatus;
        return data;
    }
}

export interface ITransportationRequestCreateDTO {
    requestType?: number;
    outputAddressId?: string;
    destinationAddressId?: string;
    userId?: string;
    weight?: number;
    volume?: number;
    note?: string | undefined;
    createdDate?: Date;
    documentStatus?: number;
}

export class TransportationRequestDTO implements ITransportationRequestDTO {
    id?: string;
    requestType?: number;
    outputAddressId?: string;
    outputAddress?: Address;
    destinationAddressId?: string;
    destinationAddress?: Address;
    userId?: string;
    user?: AspNetUser;
    weight?: number;
    volume?: number;
    note?: string | undefined;
    createdDate?: Date;
    documentStatus?: number;

    constructor(data?: ITransportationRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestType = _data["requestType"];
            this.outputAddressId = _data["outputAddressId"];
            this.outputAddress = _data["outputAddress"] ? Address.fromJS(_data["outputAddress"]) : <any>undefined;
            this.destinationAddressId = _data["destinationAddressId"];
            this.destinationAddress = _data["destinationAddress"] ? Address.fromJS(_data["destinationAddress"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
            this.weight = _data["weight"];
            this.volume = _data["volume"];
            this.note = _data["note"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.documentStatus = _data["documentStatus"];
        }
    }

    static fromJS(data: any): TransportationRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransportationRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestType"] = this.requestType;
        data["outputAddressId"] = this.outputAddressId;
        data["outputAddress"] = this.outputAddress ? this.outputAddress.toJSON() : <any>undefined;
        data["destinationAddressId"] = this.destinationAddressId;
        data["destinationAddress"] = this.destinationAddress ? this.destinationAddress.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["weight"] = this.weight;
        data["volume"] = this.volume;
        data["note"] = this.note;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["documentStatus"] = this.documentStatus;
        return data;
    }
}

export interface ITransportationRequestDTO {
    id?: string;
    requestType?: number;
    outputAddressId?: string;
    outputAddress?: Address;
    destinationAddressId?: string;
    destinationAddress?: Address;
    userId?: string;
    user?: AspNetUser;
    weight?: number;
    volume?: number;
    note?: string | undefined;
    createdDate?: Date;
    documentStatus?: number;
}

export class TransportationRequestUpdateDTO implements ITransportationRequestUpdateDTO {
    id?: string;
    requestType?: number;
    outputAddressId?: string;
    destinationAddressId?: string;
    userId?: string;
    weight?: number;
    volume?: number;
    note?: string | undefined;
    createdDate?: Date;
    documentStatus?: number;

    constructor(data?: ITransportationRequestUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestType = _data["requestType"];
            this.outputAddressId = _data["outputAddressId"];
            this.destinationAddressId = _data["destinationAddressId"];
            this.userId = _data["userId"];
            this.weight = _data["weight"];
            this.volume = _data["volume"];
            this.note = _data["note"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.documentStatus = _data["documentStatus"];
        }
    }

    static fromJS(data: any): TransportationRequestUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransportationRequestUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestType"] = this.requestType;
        data["outputAddressId"] = this.outputAddressId;
        data["destinationAddressId"] = this.destinationAddressId;
        data["userId"] = this.userId;
        data["weight"] = this.weight;
        data["volume"] = this.volume;
        data["note"] = this.note;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["documentStatus"] = this.documentStatus;
        return data;
    }
}

export interface ITransportationRequestUpdateDTO {
    id?: string;
    requestType?: number;
    outputAddressId?: string;
    destinationAddressId?: string;
    userId?: string;
    weight?: number;
    volume?: number;
    note?: string | undefined;
    createdDate?: Date;
    documentStatus?: number;
}

export class UserDTO implements IUserDTO {
    id?: string;
    firstName?: string | undefined;
    familyName?: string | undefined;
    userName?: string | undefined;
    userImage?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.familyName = _data["familyName"];
            this.userName = _data["userName"];
            this.userImage = _data["userImage"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["familyName"] = this.familyName;
        data["userName"] = this.userName;
        data["userImage"] = this.userImage;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserDTO {
    id?: string;
    firstName?: string | undefined;
    familyName?: string | undefined;
    userName?: string | undefined;
    userImage?: string | undefined;
    email?: string | undefined;
}

export class UserDTOCustomResponse implements IUserDTOCustomResponse {
    data?: UserDTO;
    error?: ErrorDTO;

    constructor(data?: IUserDTOCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserDTO.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDTO.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDTOCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTOCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDTOCustomResponse {
    data?: UserDTO;
    error?: ErrorDTO;
}

export class VehicleCreateDTO implements IVehicleCreateDTO {
    id?: string;
    vehicleType?: number;
    vehicleLicensePlate?: string | undefined;
    vehicleVolumeCapacity?: string | undefined;
    vehicleWeightCapacity?: string | undefined;
    vehicleStatus?: number;
    driverId?: string;

    constructor(data?: IVehicleCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleType = _data["vehicleType"];
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.vehicleVolumeCapacity = _data["vehicleVolumeCapacity"];
            this.vehicleWeightCapacity = _data["vehicleWeightCapacity"];
            this.vehicleStatus = _data["vehicleStatus"];
            this.driverId = _data["driverId"];
        }
    }

    static fromJS(data: any): VehicleCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleType"] = this.vehicleType;
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["vehicleVolumeCapacity"] = this.vehicleVolumeCapacity;
        data["vehicleWeightCapacity"] = this.vehicleWeightCapacity;
        data["vehicleStatus"] = this.vehicleStatus;
        data["driverId"] = this.driverId;
        return data;
    }
}

export interface IVehicleCreateDTO {
    id?: string;
    vehicleType?: number;
    vehicleLicensePlate?: string | undefined;
    vehicleVolumeCapacity?: string | undefined;
    vehicleWeightCapacity?: string | undefined;
    vehicleStatus?: number;
    driverId?: string;
}

export class VehicleUpdateDTO implements IVehicleUpdateDTO {
    id?: string;
    vehicleType?: number;
    vehicleLicensePlate?: string | undefined;
    vehicleVolumeCapacity?: string | undefined;
    vehicleWeightCapacity?: string | undefined;
    vehicleStatus?: number;
    driverId?: string;

    constructor(data?: IVehicleUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleType = _data["vehicleType"];
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.vehicleVolumeCapacity = _data["vehicleVolumeCapacity"];
            this.vehicleWeightCapacity = _data["vehicleWeightCapacity"];
            this.vehicleStatus = _data["vehicleStatus"];
            this.driverId = _data["driverId"];
        }
    }

    static fromJS(data: any): VehicleUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleType"] = this.vehicleType;
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["vehicleVolumeCapacity"] = this.vehicleVolumeCapacity;
        data["vehicleWeightCapacity"] = this.vehicleWeightCapacity;
        data["vehicleStatus"] = this.vehicleStatus;
        data["driverId"] = this.driverId;
        return data;
    }
}

export interface IVehicleUpdateDTO {
    id?: string;
    vehicleType?: number;
    vehicleLicensePlate?: string | undefined;
    vehicleVolumeCapacity?: string | undefined;
    vehicleWeightCapacity?: string | undefined;
    vehicleStatus?: number;
    driverId?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
